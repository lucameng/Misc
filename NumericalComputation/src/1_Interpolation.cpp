#include<stdio.h>
#include<math.h>
#include<string.h>
#define MAX 20

typedef struct stPoint{//Used to store data point coordinates
	double x;
	double y;
}Point;

double Lagrange(double n,Point *pt, Point *midPt){//Lagrange's interpolation
	double tmp_l=0.0;
	double error_max=0.0;
	double tmp_error=0.0;
	double lag[MAX];
	int i,j;
	for(int k=0;k<n;k++){
	tmp_l=1.0;
		
		for(i=0;i<=n;i++){
			for(j=0,tmp_l=1.0;j<=n;j++){
				if(i==j)
				continue;
				tmp_l=tmp_l*(midPt[k].x-pt[j].x)/(pt[i].x-pt[j].x);
			}
			
			lag[k]+=tmp_l*(pt[i].y);//Lagrange interpolating polynomial
		
		}
		tmp_error=abs(lag[k]-midPt[k].y);
		if(error_max<=tmp_error)
			error_max=tmp_error;//Find the maximum error
		
	}	
	return error_max;
}

double PiecewiseLinear(double n, Point *pt, Point *midPt){//Piecewise linear interpolation
	double tmp_l,tmp_error,Plf_y;
	double error_max=0.0;

	for(int i=0;i<n;i++){
		if(midPt[i].x>pt[i].x&&midPt[i].x<pt[i+1].x)
			Plf_y=(midPt[i].x-pt[i].x)*(pt[i+1].y-pt[i].y)/(pt[i+1].x-pt[i].x)+pt[i].y;		
		else
			break;
		tmp_error=abs(Plf_y-midPt[i].y);
		if(error_max<=tmp_error)
			error_max=tmp_error;//Find the maximum error
	}
	return error_max;
}


double m_Coef[MAX+1];
void ChaseMethod(double k, double *m_Coef, Point *pt){
//Interpolation coefficients of interior points are generated by Chasing Method(under First boundary condition)
	int n=(int)k;
	double h_Coef[MAX+1],alpha[MAX+1],beta[MAX+1];// multinomial coefficient
	double A_Coef[MAX+1],B_Coef[MAX+1];
	for(int i=0;i<n;i++){
		h_Coef[i]=pt[i+1].x-pt[i].x;
	} 
	
	for(int i=1;i<n;i++){
		alpha[i]=h_Coef[i-1]/(h_Coef[i-1]+h_Coef[i]);
	}
	for(int i=1;i<n;i++){
		beta[i]=3.0*( (1-alpha[i])*(pt[i].y-pt[i-1].y) / h_Coef[i-1] 
					 + alpha[i]*(pt[i+1].y-pt[i].y) /h_Coef[i] );
	} //
	
	alpha[0]=1.0;
	beta[0]=3.0*(pt[1].y-pt[0].y)/h_Coef[0];
	A_Coef[0]=-1.0/2.0*alpha[0];
	B_Coef[0]=1.0/2.0*beta[0];
	m_Coef[n]=3.0*(pt[n].y-pt[n-1].y)/h_Coef[n-1];
	
	for(int i=1;i<n;i++){
		A_Coef[i]=(-alpha[i])/(2.0+(1-alpha[i])*A_Coef[i-1]);
		B_Coef[i]=(beta[i]-(1.0-alpha[i])*B_Coef[i-1])/(2.0+(1-alpha[i])*A_Coef[i-1]);
	}
	
	
	for(int i=n-1;i>=0;i--){
		m_Coef[i]=A_Coef[i]*m_Coef[i+1]+B_Coef[i];
	}
}

double Spline(double n, Point *pt, Point *midPt){//Calculates the value of the spline interpolation formula
	double tmp_l,tmp_error;
	double error_max=0.0;
	double Sp_Poly=0.0;
	ChaseMethod(n, m_Coef, pt);		
	for(int i=0;i<n;i++){//Find the formula of spline interpolation
		double poly_pt1=(1+2*(midPt[i].x-pt[i].x)/(pt[i+1].x-pt[i].x))//part 1 of spline interpolation polynomial, the same below
							*(midPt[i].x-pt[i+1].x)*(midPt[i].x-pt[i+1].x)
							/((pt[i].x-pt[i+1].x)*(pt[i].x-pt[i+1].x))*pt[i].y;
		double poly_pt2=(1+2*(midPt[i].x-pt[i+1].x)/(pt[i].x-pt[i+1].x))
							*(midPt[i].x-pt[i].x)*(midPt[i].x-pt[i].x)/
							((pt[i+1].x-pt[i].x)*(pt[i+1].x-pt[i].x))*pt[i+1].y;
		double poly_pt3=(midPt[i].x-pt[i].x)*(midPt[i].x-pt[i+1].x)*(midPt[i].x-pt[i+1].x)
						/((pt[i].x-pt[i+1].x)*(pt[i].x-pt[i+1].x))*m_Coef[i];
		double poly_pt4=(midPt[i].x-pt[i+1].x)*(midPt[i].x-pt[i].x)*(midPt[i].x-pt[i].x)
						/((pt[i].x-pt[i+1].x)*(pt[i].x-pt[i+1].x))*m_Coef[i+1];
		Sp_Poly=poly_pt1+poly_pt2+poly_pt3+poly_pt4;//The spline interpolation formula is expressed by the combination of 4 polynomials
		tmp_error=abs(Sp_Poly-midPt[i].y);
		if(error_max<=tmp_error)
			error_max=tmp_error;//Find the maximum error		
	}	
	return error_max;
}


int main(){
	Point pt[MAX+1],midPt[MAX+1];//points and interval midpoints
	double a,b,h,n;//Lower limit, upper limit, width, number of interval
	double l_error_max,
			pl_error_max,
			cs_error_max;//The maximum error of the three different interpolation methods
	int i,j;	
	scanf("%lf",&a);
	scanf("%lf",&b);
	scanf("%lf",&n);
	
	h=(b-a)/n;
	for(i=0;i<=n;i++){
		pt[i].x=a+i*h;
		pt[i].y=exp(-2*pt[i].x);
		if(i>=1){
			midPt[i-1].x=(pt[i-1].x+pt[i].x)/2.0;
			midPt[i-1].y=exp(-2*midPt[i-1].x);//The true value of the midpoint of the interval
		}		
	}       	
	l_error_max=Lagrange(n, pt, midPt);
	pl_error_max=PiecewiseLinear(n, pt, midPt);
	cs_error_max=Spline(n, pt, midPt);
	printf("%.6le\n%.6le\n%.6le",l_error_max,pl_error_max,cs_error_max);		
			
	return 0;
}